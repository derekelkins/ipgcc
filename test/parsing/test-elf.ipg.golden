ELF
  -> H[0, 128]
     for i = 0 to H.e_shnum do SH[H.e_shoff + i * H.e_shentsize, H.e_shoff + (i + 1) * H.e_shentsize]
     for i = 1 to H.e_shnum do Sec(SH(i).sh_type)[SH(i).sh_offset, SH(i).sh_offset + SH(i).sh_size]
     { header = H.this }
     { section_headers = SH.these }
     { sections = projectSections(Sec.these) };

Sec(sh_type)
  -> ?[ sh_type == 6 ]
     DynSec[0, EOI]
     { section = DynSec.section }
   / ?[ sh_type == 3 ]
     StrSec[0, EOI]
     { section = StrSec.section }
   / ?[ sh_type == 11 || sh_type == 2 ]
     DynSymSec[0, EOI]
     { section = DynSymSec.section }
   / ?[ sh_type == 7 ]
     NoteSec[0, EOI]
     { section = NoteSec.section }
   / ?[ sh_type == 9 ]
     RelSec[0, EOI]
     { section = RelSec.section }
   / ?[ sh_type == 4 ]
     RelAddEndSec[0, EOI]
     { section = RelAddEndSec.section }
   / ?[ sh_type == 8 ]
     { section = empty() }
   / { section = *[0, EOI] };

NUL_BYTE
  -> "\x00"[0, 1];

U8
  -> { value = .[0] };

U16
  -> { bs = *[0, 2] }
     { value = bs[0] | bs[1] << 8 };

U32
  -> { bs = *[0, 4] }
     { value = bs[0] | bs[1] << 8 | bs[2] << 16 | bs[3] << 24 };

U64
  -> { bs = *[0, 8] }
     { value = bs[0] | bs[1] << 8 | bs[2] << 16 | bs[3] << 24 | bs[4] << 32 | bs[5] << 40 | bs[6] << 48 | bs[7] << 56 };

H
  -> "\x7fELF"[0, 4]
     { ei_class = .[4] }
     { ei_data = .[5] }
     { ei_version = .[6] }
     { abi = .[7] }
     { abi_version = .[8] }
     U16[16, 18]
     { e_type = U16.value }
     U16[U16.END, EOI]
     { e_machine = U16.value }
     U32[U16.END, EOI]
     { e_version = U32.value }
     U64[U32.END, EOI]
     { e_entry = U64.value }
     U64[U64.END, EOI]
     { e_phoff = U64.value }
     U64[U64.END, EOI]
     { e_shoff = U64.value }
     U32[U64.END, EOI]
     { e_flags = U32.value }
     U16[U32.END, EOI]
     { e_ehsize = U16.value }
     U16[U16.END, EOI]
     { e_phentsize = U16.value }
     U16[U16.END, EOI]
     { e_phnum = U16.value }
     U16[U16.END, EOI]
     { e_shentsize = U16.value }
     U16[U16.END, EOI]
     { e_shnum = U16.value }
     U16[U16.END, EOI]
     { e_shstrndx = U16.value };

SH
  -> U32[0, EOI]
     { sh_name = U32.value }
     U32[U32.END, EOI]
     { sh_type = U32.value }
     U64[U32.END, EOI]
     { sh_flags = U64.value }
     U64[U64.END, EOI]
     { sh_addr = U64.value }
     U64[U64.END, EOI]
     { sh_offset = U64.value }
     U64[U64.END, EOI]
     { sh_size = U64.value }
     U32[U64.END, EOI]
     { sh_link = U32.value }
     U32[U32.END, EOI]
     { sh_info = U32.value }
     U32[U32.END, EOI]
     { sh_addralign = U32.value }
     U64[U32.END, EOI]
     { sh_entsize = U64.value };

DynSec
  -> for i = 0 to EOI / 16 do DynSecEntry[16 * i, 16 * (i + 1)]
     { section = DynSecEntry.these };

DynSecEntry
  -> U64[0, EOI]
     { tag = U64.value }
     U64[U64.END, EOI]
     { value_or_ptr = U64.value };

StrSec
  -> repeat Str.string
     { section = values };

Str
  -> repeat U8.value until NUL_BYTE
     { string = decodeAscii(values) };

DynSymSec
  -> for i = 0 to EOI / 24 do DynSymSecEntry[24 * i, 24 * (i + 1)]
     { section = DynSymSecEntry.these };

DynSymSecEntry
  -> U32[0, EOI]
     { sh_name = U32.value }
     { st_info = .[U32.END] }
     { st_other = .[U32.END + 1] }
     U16[U32.END + 2, EOI]
     { st_shndx = U16.value }
     U64[U16.END, EOI]
     { st_value = U64.value }
     U64[U64.END, EOI]
     { st_size = U64.value };

NoteSec
  -> repeat NoteSecEntry.entry
     { section = values };

NoteSecEntry
  -> U32[0, EOI]
     { len_name = U32.value }
     U32[U32.END, EOI]
     { len_descriptor = U32.value }
     U32[U32.END, EOI]
     { type = U32.value }
     Name[U32.END, U32.END + len_name]
     Descriptor[Name.END + (-len_name & 3), Name.END + (-len_name & 3) + len_descriptor]
     { entry = makeEntry(Name.value, Descriptor.value, type) };

Name
  -> { value = *[0, EOI - 1] }
     "\x00"[EOI - 1, EOI];

Descriptor
  -> { value = *[0, EOI] };

RelAddEndSec
  -> for i = 0 to EOI / 24 do RelAddEndSecEntry[24 * i, 24 * (i + 1)]
     { section = RelAddEndSecEntry.these };

RelAddEndSecEntry
  -> U64[0, EOI]
     { offset = U64.value }
     U64[U64.END, EOI]
     { info = U64.value }
     U64[U64.END, EOI]
     { addend = U64.value };

RelSec
  -> for i = 0 to EOI / 16 do RelSecEntry[16 * i, 16 * (i + 1)]
     { section = RelSecEntry.these };

RelSecEntry
  -> U64[0, EOI]
     { offset = U64.value }
     U64[U64.END, EOI]
     { info = U64.value };